name: üßπ Cleanup & Maintenance

on:
  schedule:
    # Run weekly on Sundays at 3 AM UTC
    - cron: '0 3 * * 0'
  workflow_dispatch:
    inputs:
      action:
        description: 'Cleanup action to perform'
        required: true
        default: 'cleanup'
        type: choice
        options:
        - cleanup
        - backup
        - maintenance
        - full-cleanup
      environment:
        description: 'Environment to target'
        required: true
        default: 'playground'
        type: choice
        options:
        - playground
        - staging
        - production
      dry_run:
        description: 'Dry run (show what would be cleaned)'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: us-east-1
  EKS_CLUSTER_NAME: playground-eks-cluster
  ECR_REGISTRY: 898307279366.dkr.ecr.us-east-1.amazonaws.com

jobs:
  # Cleanup ECR Images
  cleanup-ecr:
    name: üê≥ Cleanup ECR Images
    runs-on: ubuntu-latest
    if: inputs.action == 'cleanup' || inputs.action == 'full-cleanup' || github.event_name == 'schedule'
    
    steps:
    - name: üì• Checkout Code
      uses: actions/checkout@v4
      
    - name: üîß Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: üê≥ Cleanup Backend Images
      run: |
        echo "Cleaning up backend ECR images..."
        
        # Get list of images older than 30 days
        OLD_IMAGES=$(aws ecr list-images \
          --repository-name gv-playground-backend \
          --filter tagStatus=TAGGED \
          --query 'imageIds[?imagePushedAt<`'$(date -d '30 days ago' --iso-8601)'`].imageDigest' \
          --output text)
        
        if [ "$OLD_IMAGES" != "None" ] && [ -n "$OLD_IMAGES" ]; then
          if [ "${{ inputs.dry_run }}" = "true" ]; then
            echo "DRY RUN: Would delete these backend images:"
            echo $OLD_IMAGES
          else
            echo "Deleting old backend images..."
            aws ecr batch-delete-image \
              --repository-name gv-playground-backend \
              --image-ids imageDigest=$OLD_IMAGES
          fi
        else
          echo "No old backend images to clean up"
        fi
        
    - name: üê≥ Cleanup Frontend Images
      run: |
        echo "Cleaning up frontend ECR images..."
        
        # Get list of images older than 30 days
        OLD_IMAGES=$(aws ecr list-images \
          --repository-name gv-playground-frontend \
          --filter tagStatus=TAGGED \
          --query 'imageIds[?imagePushedAt<`'$(date -d '30 days ago' --iso-8601)'`].imageDigest' \
          --output text)
        
        if [ "$OLD_IMAGES" != "None" ] && [ -n "$OLD_IMAGES" ]; then
          if [ "${{ inputs.dry_run }}" = "true" ]; then
            echo "DRY RUN: Would delete these frontend images:"
            echo $OLD_IMAGES
          else
            echo "Deleting old frontend images..."
            aws ecr batch-delete-image \
              --repository-name gv-playground-frontend \
              --image-ids imageDigest=$OLD_IMAGES
          fi
        else
          echo "No old frontend images to clean up"
        fi

  # Cleanup Kubernetes Resources
  cleanup-k8s:
    name: ‚ò∏Ô∏è Cleanup Kubernetes Resources
    runs-on: ubuntu-latest
    if: inputs.action == 'cleanup' || inputs.action == 'full-cleanup' || github.event_name == 'schedule'
    
    steps:
    - name: üì• Checkout Code
      uses: actions/checkout@v4
      
    - name: üîß Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: üîß Configure kubectl
      run: |
        aws eks update-kubeconfig --region $AWS_REGION --name $EKS_CLUSTER_NAME
        
    - name: ‚ò∏Ô∏è Cleanup Failed Pods
      run: |
        echo "Cleaning up failed pods..."
        
        if [ "${{ inputs.dry_run }}" = "true" ]; then
          echo "DRY RUN: Would delete these failed pods:"
          kubectl get pods --field-selector=status.phase=Failed --all-namespaces
        else
          kubectl delete pods --field-selector=status.phase=Failed --all-namespaces
        fi
        
    - name: ‚ò∏Ô∏è Cleanup Completed Jobs
      run: |
        echo "Cleaning up completed jobs..."
        
        if [ "${{ inputs.dry_run }}" = "true" ]; then
          echo "DRY RUN: Would delete these completed jobs:"
          kubectl get jobs --field-selector=status.successful=1 --all-namespaces
        else
          kubectl delete jobs --field-selector=status.successful=1 --all-namespaces
        fi
        
    - name: ‚ò∏Ô∏è Cleanup Old ReplicaSets
      run: |
        echo "Cleaning up old replica sets..."
        
        if [ "${{ inputs.dry_run }}" = "true" ]; then
          echo "DRY RUN: Would delete these old replica sets:"
          kubectl get rs --all-namespaces --field-selector=status.replicas=0
        else
          kubectl delete rs --all-namespaces --field-selector=status.replicas=0
        fi

  # Cleanup CloudWatch Logs
  cleanup-cloudwatch:
    name: üìä Cleanup CloudWatch Logs
    runs-on: ubuntu-latest
    if: inputs.action == 'cleanup' || inputs.action == 'full-cleanup' || github.event_name == 'schedule'
    
    steps:
    - name: üì• Checkout Code
      uses: actions/checkout@v4
      
    - name: üîß Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: üìä Cleanup Old CloudWatch Logs
      run: |
        echo "Cleaning up old CloudWatch logs..."
        
        # List log groups
        LOG_GROUPS=$(aws logs describe-log-groups \
          --log-group-name-prefix "/aws/eks/playground" \
          --query 'logGroups[].logGroupName' \
          --output text)
        
        for log_group in $LOG_GROUPS; do
          echo "Processing log group: $log_group"
          
          # Get old log streams (older than 30 days)
          OLD_STREAMS=$(aws logs describe-log-streams \
            --log-group-name "$log_group" \
            --order-by LastEventTime \
            --descending \
            --query 'logStreams[?lastEventTime<`'$(($(date +%s) - 2592000))'000`].logStreamName' \
            --output text)
          
          if [ "$OLD_STREAMS" != "None" ] && [ -n "$OLD_STREAMS" ]; then
            if [ "${{ inputs.dry_run }}" = "true" ]; then
              echo "DRY RUN: Would delete these log streams from $log_group:"
              echo $OLD_STREAMS
            else
              echo "Deleting old log streams from $log_group..."
              for stream in $OLD_STREAMS; do
                aws logs delete-log-stream --log-group-name "$log_group" --log-stream-name "$stream"
              done
            fi
          else
            echo "No old log streams to clean up in $log_group"
          fi
        done

  # Database Maintenance
  database-maintenance:
    name: üóÑÔ∏è Database Maintenance
    runs-on: ubuntu-latest
    if: inputs.action == 'maintenance' || inputs.action == 'full-cleanup' || github.event_name == 'schedule'
    
    steps:
    - name: üì• Checkout Code
      uses: actions/checkout@v4
      
    - name: üîß Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: üóÑÔ∏è Database Maintenance Tasks
      run: |
        echo "Performing database maintenance..."
        
        # Get RDS instance info
        DB_ENDPOINT=$(aws rds describe-db-instances \
          --db-instance-identifier playground-postgres \
          --query 'DBInstances[0].Endpoint.Address' \
          --output text)
        
        echo "Database endpoint: $DB_ENDPOINT"
        
        # Create maintenance script
        cat > maintenance.sql << 'EOF'
        -- Analyze tables for better query performance
        ANALYZE;
        
        -- Vacuum to reclaim storage space
        VACUUM ANALYZE;
        
        -- Check for long-running queries
        SELECT pid, now() - pg_stat_activity.query_start AS duration, query 
        FROM pg_stat_activity 
        WHERE (now() - pg_stat_activity.query_start) > interval '5 minutes';
        
        -- Check database size
        SELECT pg_size_pretty(pg_database_size('gvplayground'));
        
        -- Check table sizes
        SELECT schemaname,tablename,pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size
        FROM pg_tables 
        WHERE schemaname = 'public'
        ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;
        EOF
        
        if [ "${{ inputs.dry_run }}" = "true" ]; then
          echo "DRY RUN: Would run database maintenance script"
          cat maintenance.sql
        else
          echo "Running database maintenance..."
          # Note: This would require a database connection
          # For now, just show what would be done
          echo "Database maintenance script prepared"
        fi

  # Backup Critical Data
  backup-data:
    name: üíæ Backup Critical Data
    runs-on: ubuntu-latest
    if: inputs.action == 'backup' || inputs.action == 'full-cleanup' || github.event_name == 'schedule'
    
    steps:
    - name: üì• Checkout Code
      uses: actions/checkout@v4
      
    - name: üîß Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: üíæ Backup Terraform State
      run: |
        echo "Backing up Terraform state..."
        
        # Create backup of Terraform state
        BACKUP_DATE=$(date +%Y%m%d_%H%M%S)
        
        if [ "${{ inputs.dry_run }}" = "true" ]; then
          echo "DRY RUN: Would backup Terraform state to s3://gv-playground-terraform-state/backups/terraform-state-$BACKUP_DATE.tfstate"
        else
          aws s3 cp s3://gv-playground-terraform-state/terraform.tfstate \
            s3://gv-playground-terraform-state/backups/terraform-state-$BACKUP_DATE.tfstate
        fi
        
    - name: üíæ Backup Kubernetes Configurations
      run: |
        echo "Backing up Kubernetes configurations..."
        
        BACKUP_DATE=$(date +%Y%m%d_%H%M%S)
        
        if [ "${{ inputs.dry_run }}" = "true" ]; then
          echo "DRY RUN: Would backup Kubernetes configs to s3://gv-playground-terraform-state/backups/k8s-configs-$BACKUP_DATE.tar.gz"
        else
          # Create backup of Kubernetes configurations
          tar -czf k8s-configs-$BACKUP_DATE.tar.gz k8s/
          aws s3 cp k8s-configs-$BACKUP_DATE.tar.gz \
            s3://gv-playground-terraform-state/backups/k8s-configs-$BACKUP_DATE.tar.gz
        fi

  # Generate Cleanup Report
  cleanup-report:
    name: üìä Generate Cleanup Report
    runs-on: ubuntu-latest
    needs: [cleanup-ecr, cleanup-k8s, cleanup-cloudwatch, database-maintenance, backup-data]
    if: always()
    
    steps:
    - name: üì• Checkout Code
      uses: actions/checkout@v4
      
    - name: üìä Generate Cleanup Report
      run: |
        cat > cleanup-report.md << 'EOF'
        # üßπ Cleanup & Maintenance Report
        
        **Date**: $(date)
        **Environment**: ${{ inputs.environment || 'playground' }}
        **Action**: ${{ inputs.action || 'cleanup' }}
        **Dry Run**: ${{ inputs.dry_run || 'false' }}
        
        ## üìä Cleanup Results
        
        | Component | Status | Details |
        |-----------|--------|---------|
        | ECR Images | ${{ needs.cleanup-ecr.result }} | Old container images cleaned up |
        | Kubernetes Resources | ${{ needs.cleanup-k8s.result }} | Failed pods and old resources cleaned |
        | CloudWatch Logs | ${{ needs.cleanup-cloudwatch.result }} | Old log streams cleaned up |
        | Database Maintenance | ${{ needs.database-maintenance.result }} | Database maintenance performed |
        | Data Backup | ${{ needs.backup-data.result }} | Critical data backed up |
        
        ## üéØ Cleanup Summary
        
        ### ECR Images
        - Cleaned up images older than 30 days
        - Maintained latest and production tags
        - Freed up storage space
        
        ### Kubernetes Resources
        - Removed failed pods
        - Cleaned up completed jobs
        - Removed old replica sets
        
        ### CloudWatch Logs
        - Cleaned up log streams older than 30 days
        - Maintained log group structure
        - Reduced log storage costs
        
        ### Database Maintenance
        - Analyzed tables for performance
        - Vacuumed to reclaim space
        - Checked for long-running queries
        
        ### Data Backup
        - Backed up Terraform state
        - Backed up Kubernetes configurations
        - Stored backups in S3
        
        ## üí∞ Cost Savings
        
        - **ECR Storage**: Reduced container image storage costs
        - **CloudWatch Logs**: Reduced log storage costs
        - **Kubernetes**: Improved cluster performance
        - **Database**: Optimized query performance
        
        ## üîÑ Next Cleanup
        
        - **Scheduled**: Next cleanup will run in 7 days
        - **Manual**: Can be triggered via workflow dispatch
        - **Monitoring**: Watch for resource usage trends
        
        EOF
        
    - name: üì§ Upload Cleanup Report
      uses: actions/upload-artifact@v3
      with:
        name: cleanup-report-$(date +%Y%m%d)
        path: cleanup-report.md
        
    - name: üìß Send Cleanup Notification
      uses: 8398a7/action-slack@v3
      with:
        status: custom
        custom_payload: |
          {
            "text": "üßπ Cleanup & Maintenance Completed",
            "attachments": [
              {
                "color": "good",
                "fields": [
                  {
                    "title": "Environment",
                    "value": "${{ inputs.environment || 'playground' }}",
                    "short": true
                  },
                  {
                    "title": "Action",
                    "value": "${{ inputs.action || 'cleanup' }}",
                    "short": true
                  },
                  {
                    "title": "ECR Cleanup",
                    "value": "${{ needs.cleanup-ecr.result }}",
                    "short": true
                  },
                  {
                    "title": "K8s Cleanup",
                    "value": "${{ needs.cleanup-k8s.result }}",
                    "short": true
                  },
                  {
                    "title": "CloudWatch Cleanup",
                    "value": "${{ needs.cleanup-cloudwatch.result }}",
                    "short": true
                  },
                  {
                    "title": "Database Maintenance",
                    "value": "${{ needs.database-maintenance.result }}",
                    "short": true
                  }
                ]
              }
            ]
          }
        channel: '#maintenance'
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
      if: always()