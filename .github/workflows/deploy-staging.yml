name: Deploy to Staging

on:
  push:
    branches: [ develop ]
  workflow_dispatch:

env:
  NODE_VERSION: '18'
  AWS_REGION: 'us-east-1'
  ENVIRONMENT: 'staging'
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com

jobs:
  # Build and Push Images
  build-and-push:
    name: Build and Push Images
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Extract metadata for backend
      id: meta-backend
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.ECR_REGISTRY }}/gv-playground-backend
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          
    - name: Extract metadata for frontend
      id: meta-frontend
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.ECR_REGISTRY }}/gv-playground-frontend
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          
    - name: Build and push backend image
      uses: docker/build-push-action@v5
      with:
        context: ./backend
        push: true
        tags: ${{ steps.meta-backend.outputs.tags }}
        labels: ${{ steps.meta-backend.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64
        
    - name: Build and push frontend image
      uses: docker/build-push-action@v5
      with:
        context: ./frontend
        push: true
        tags: ${{ steps.meta-frontend.outputs.tags }}
        labels: ${{ steps.meta-frontend.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64

  # Deploy Infrastructure
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: build-and-push
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.6.0
        
    - name: Terraform Init
      run: |
        cd infrastructure
        terraform init
        
    - name: Terraform Plan
      run: |
        cd infrastructure
        terraform plan -var="environment=${{ env.ENVIRONMENT }}" -var="rds_password=${{ secrets.RDS_PASSWORD }}" -out=tfplan
        
    - name: Terraform Apply
      run: |
        cd infrastructure
        terraform apply -auto-approve tfplan
        
    - name: Get EKS cluster info
      run: |
        cd infrastructure
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name $(terraform output -raw eks_cluster_name)
        kubectl cluster-info

  # Deploy Applications
  deploy-applications:
    name: Deploy Applications
    runs-on: ubuntu-latest
    needs: deploy-infrastructure
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'
        
    - name: Configure kubectl
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.ENVIRONMENT }}-eks-cluster
        
    - name: Create namespace
      run: |
        kubectl create namespace gv-playground --dry-run=client -o yaml | kubectl apply -f -
        
    - name: Create ConfigMap for backend
      run: |
        kubectl create configmap backend-config \
          --from-literal=DATABASE_URL="${{ secrets.DATABASE_URL }}" \
          --from-literal=JWT_SECRET="${{ secrets.JWT_SECRET }}" \
          --from-literal=NODE_ENV="staging" \
          --namespace=gv-playground \
          --dry-run=client -o yaml | kubectl apply -f -
          
    - name: Create ConfigMap for frontend
      run: |
        kubectl create configmap frontend-config \
          --from-literal=REACT_APP_API_URL="http://${{ env.ENVIRONMENT }}-alb-$(aws elbv2 describe-load-balancers --region ${{ env.AWS_REGION }} --query 'LoadBalancers[?contains(LoadBalancerName, `${{ env.ENVIRONMENT }}-alb`)].DNSName' --output text)" \
          --namespace=gv-playground \
          --dry-run=client -o yaml | kubectl apply -f -
          
    - name: Deploy backend
      run: |
        kubectl apply -f k8s/backend-deployment.yaml
        kubectl apply -f k8s/backend-service.yaml
        
    - name: Deploy frontend
      run: |
        kubectl apply -f k8s/frontend-deployment.yaml
        kubectl apply -f k8s/frontend-service.yaml
        
    - name: Deploy ingress
      run: |
        kubectl apply -f k8s/ingress.yaml
        
    - name: Wait for deployments
      run: |
        kubectl wait --for=condition=available --timeout=300s deployment/backend -n gv-playground
        kubectl wait --for=condition=available --timeout=300s deployment/frontend -n gv-playground

  # Run Integration Tests
  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: deploy-applications
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Get application URL
      id: get-url
      run: |
        ALB_DNS=$(aws elbv2 describe-load-balancers --region ${{ env.AWS_REGION }} --query 'LoadBalancers[?contains(LoadBalancerName, `${{ env.ENVIRONMENT }}-alb`)].DNSName' --output text)
        echo "url=http://$ALB_DNS" >> $GITHUB_OUTPUT
        
    - name: Wait for application to be ready
      run: |
        for i in {1..30}; do
          if curl -f ${{ steps.get-url.outputs.url }}/api/health; then
            echo "Application is ready!"
            break
          fi
          echo "Waiting for application... ($i/30)"
          sleep 10
        done
        
    - name: Run API tests
      run: |
        # Test health endpoint
        curl -f ${{ steps.get-url.outputs.url }}/api/health
        
        # Test registration
        curl -X POST ${{ steps.get-url.outputs.url }}/api/auth/register \
          -H "Content-Type: application/json" \
          -d '{"name":"Test User","email":"test@example.com","password":"password123"}' \
          -f
          
        # Test login
        curl -X POST ${{ steps.get-url.outputs.url }}/api/auth/login \
          -H "Content-Type: application/json" \
          -d '{"email":"test@example.com","password":"password123"}' \
          -f
          
    - name: Test frontend
      run: |
        curl -f ${{ steps.get-url.outputs.url }}/health

  # Performance Tests
  performance-tests:
    name: Performance Tests
    runs-on: ubuntu-latest
    needs: integration-tests
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Get application URL
      id: get-url
      run: |
        ALB_DNS=$(aws elbv2 describe-load-balancers --region ${{ env.AWS_REGION }} --query 'LoadBalancers[?contains(LoadBalancerName, `${{ env.ENVIRONMENT }}-alb`)].DNSName' --output text)
        echo "url=http://$ALB_DNS" >> $GITHUB_OUTPUT
        
    - name: Install k6
      run: |
        sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
        echo "deb https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
        sudo apt-get update
        sudo apt-get install k6
        
    - name: Run performance tests
      run: |
        echo "import http from 'k6/http';" > performance-test.js
        echo "import { check } from 'k6';" >> performance-test.js
        echo "export let options = { vus: 10, duration: '30s' };" >> performance-test.js
        echo "export default function() {" >> performance-test.js
        echo "  let response = http.get('${{ steps.get-url.outputs.url }}/api/health');" >> performance-test.js
        echo "  check(response, { 'status is 200': (r) => r.status === 200 });" >> performance-test.js
        echo "}" >> performance-test.js
        k6 run performance-test.js

  # Deployment Summary
  deployment-summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-infrastructure, deploy-applications, integration-tests, performance-tests]
    if: always()
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Get deployment info
      id: deployment-info
      run: |
        ALB_DNS=$(aws elbv2 describe-load-balancers --region ${{ env.AWS_REGION }} --query 'LoadBalancers[?contains(LoadBalancerName, `${{ env.ENVIRONMENT }}-alb`)].DNSName' --output text)
        echo "url=http://$ALB_DNS" >> $GITHUB_OUTPUT
        
    - name: Deployment Summary
      run: |
        echo "## 🚀 Staging Deployment Complete!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### 📊 Deployment Status" >> $GITHUB_STEP_SUMMARY
        echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
        echo "| Build & Push | ${{ needs.build-and-push.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Infrastructure | ${{ needs.deploy-infrastructure.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Applications | ${{ needs.deploy-applications.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Integration Tests | ${{ needs.integration-tests.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Performance Tests | ${{ needs.performance-tests.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### 🔗 Application URLs" >> $GITHUB_STEP_SUMMARY
        echo "- **Frontend**: ${{ steps.deployment-info.outputs.url }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Backend API**: ${{ steps.deployment-info.outputs.url }}/api" >> $GITHUB_STEP_SUMMARY
        echo "- **Health Check**: ${{ steps.deployment-info.outputs.url }}/api/health" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### 📝 Next Steps" >> $GITHUB_STEP_SUMMARY
        echo "1. Test the application in staging environment" >> $GITHUB_STEP_SUMMARY
        echo "2. Create a pull request to main branch for production deployment" >> $GITHUB_STEP_SUMMARY
        echo "3. Monitor application logs and metrics" >> $GITHUB_STEP_SUMMARY